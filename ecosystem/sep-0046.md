# Upgradable Contracts SEP
## Preamble
```
SEP: TBD
Title: Stellar Web Authentication for Contract Accounts
Author: OpenZeppelin, Boyan Barakov <@brozorec>, Özgün Özerk <@ozgunozerk>
Track: Standard
Status: Draft
Created: 2025-03-07
Updated: 2025-03-07
Version: 0.1.0
Discussion: https://github.com/stellar/stellar-protocol/discussions/1670
```
## Summary

A standard for smart contracts defining the specifications on how to upgrade their WASM bytecode.

## Motivation

Soroban contracts are mutable by default unlike many other smart contract platforms such as Ethereum. Mutability in the context of Soroban refers to the ability of a smart contract to modify its WASM bytecode, thereby altering its function interface, execution logic, or metadata. 

However, there are cases where immutable contracts are preferable, such as when immutability guarantees are essential for trustless applications or when a contract’s logic must remain fixed to comply with regulatory requirements. In such scenarios, non-upgradeability ensures that the contract's behavior remains predictable and secure.

Soroban provides a built-in, protocol-level defined mechanism for contract upgrades, allowing contracts to upgrade themselves if they are explicitly designed to do so, thus delegating the decision for it to the application layer.

This native upgrade mechanism offers significant advantages. One of them is the flexibility it offers to contract developers who can choose to make the contract immutable by simply not provisioning upgradability mechanics. On the other hand, providing upgradability on a protocol level significantly reduces the risk surface. This becomes particularly evident when compared to Ethereum, which lacks native support for upgradability, necessitating the development of various upgradability patterns, each with its own trade-offs. Despite the availability of tooling, handling upgrades in Ethereum remains a complex and error-prone process.

While Soroban’s built-in upgradeability eliminates many of these challenges, certain caveats must still be considered. Contract upgrades require additional validation and verification to ensure security and compatibility.

### Considerations for Upgradability

To mitigate risks associated with contract upgrades, we should establish guidelines for additional validation checks. Some potential checks include:
- Ensuring that the new contract does not include a constructor, as it will not be invoked.
- Verifying that the new contract includes an upgradability mechanism, preventing an unintended loss of upgradability.
- Checking for storage consistency, ensuring that the new contract does not inadvertently introduce storage mismatches.
- Comparing version metadata to confirm that the upgrade genuinely modifies the contract’s behavior.

These checks can be implemented in upgrade tooling, providing warnings or requiring explicit confirmations for potential breaking changes.

This SEP proposes a minimal standardization of the upgrade interface to facilitate these efforts, ensuring a secure and well-defined approach to contracts upgradability.

## Abstract

This SEP defines a standardized upgradability mechanism for Soroban contracts that includes:
- Explicit versioning via metadata.
- A standardized `upgrade()` function.
- A structured approach for handling pre- and post-upgrade logic.

## Specification
### Versioning

Each contract should include a version identifier in its metadata to facilitate tracking and validation. The version of the WASM bytecode is stored using `soroban_sdk::contractmeta!` where:
- "key": `binver`,
- "value": a string that follows Semantic Versioning ([SemVer](https://semver.org/)) to differentiate between breaking and non-breaking changes.

The Soroban SDK may automatically embed this metadata by reading from the crate version to streamline adoption.

### Interface
```rust
#[contractclient(name = "UpgradeableClient")]
pub trait Upgradable {
    fn upgrade(e: soroban_sdk::Env, new_wasm_hash: soroban_sdk::BytesN<32>);
}
```
### Example Usage

```rust
contractmeta!(key = "binver", val = "0.1.12")

#[contractimpl]
impl Upgradeable for SomeContract {
    pub fn upgrade(e: Env, new_wasm_hash: BytesN<32>) {
        let owner: Address = e.storage().instance().get(&OWNER).unwrap();
        owner.require_auth();

        e.deployer().update_current_contract_wasm(new_wasm_hash);
    }
}
```
### Pre- and Post-Upgrade Handling

Soroban’s architecture prevents calling functions in the newly deployed WASM within the same invocation. Therefore, pre- or post-upgrade housekeeping (such as data migrations) must be handled separately.

Recommended best practices:
- Define a dedicated `migrate()` function for pre- or post-upgrade actions.
- Ensure one-time execution of migration functions, if applicable.
- Implement access control to prevent unauthorized calls.

## Design Rationale
1. Versioning in metadata was preferred over defining a dedicated `version()` function for the following reasons:
    - the wasm binary format already specifies a dedicated section for metadata as `contractmetav0` that’s already well leveraged by the Soroban SDK and the executable version seems a logical candidate to get stored there
    - the version is static for a binary, and won’t change between different deployments
    - the overhead on the binary size.
 2. The key `binver` is chosen for consistency with the already existing `rsver` and `rssdkver` in the metadata.
 3. This SEP doesn’t define an event emission because a system event [gets already emitted](https://github.com/stellar/rs-soroban-env/blob/e3feadbc570b9fb88769dbea26e83a52f48cca2e/soroban-env-host/src/events/system_events.rs#L16) when updating a contract executable code, making additional event definitions unnecessary.
 4. This SEP doesn’t define access control for the `upgrade()` function as this is specific for every implementation.
 5. The minimal signature of the `upgrade()` functions also facilitates rollbacks if needed.

## Changelog

- `0.1.0`: Initial draft
