## Preamble

```
SEP: 0034
Title: Wallet Request Attribution for Anchors
Author: Jake Urban, Leigh McCulloch
Track: Standard
Status: Draft
Created: 2020-08-17
Discussion: https://github.com/stellar/stellar-protocol/issues/685
```

## Simple Summary
This protocol defines how anchors can cryptographically attribute transaction requests to wallet applications. 

## Motivation
In general, web services may want to attribute resources created or actions taken on their service to client applications. Because requests headers like `User-Agent` can be spoofed, anchors require a cryptographically secure method of verifying a client's identity.

For example, an anchor server may not charge fees for transactions created using a particular wallet. In this case, the resource is the deposit or withdrawal transaction, but the resource or action could be related to different use cases.

## Abstract
This following protocol involves 3 parties:

- The Wallet: the application requesting the transaction with the anchor server 
- the wallet signing server: the web server that claims ownership of the wallet
    - note that frontend-only wallets _must_ add a backend web server to comply with this protocol
- The Anchor Server: the web server that verifies the wallet's claims

At a high level, the wallet server generates a [JSON Web Signature](https://www.rfc-editor.org/rfc/rfc7515.html) (JWS) that the wallet application receives and includes in future requests to the anchor server. The anchor server verifies that the token included in the request was signed by the wallet server, proving that the wallet takes ownership of the request being made.

How the client application communicates with the signing server and receives the JWS is out of the scope of this document. The only requirement is for the signing server to return a JWS in the format descibed in the next section. Wallet signing servers should not accept requests for tokens if the client cannot be authenticated or if the request omits the transaction ID the wallet received from the anchor.

## Token

The JWS can be generated using two JSON objects and a JSON Web Key ([JWK](https://www.rfc-editor.org/rfc/rfc7517.html)). The JWK itself is generated using the wallet signing server's `SIGNING_KEY` and associated secret key listed in the server's [`stellar.toml`](sep-0001.md).

The first JSON object is the [JWS Protected Header](https://www.rfc-editor.org/rfc/rfc7515.html#section-4):
```json
{
    "typ": "JWT",
    "alg": "EdDSA",
    "kid": "GCR5WQYXYT4ECBQ3SBALXHICPEVTWKY75XKKZ3ZMF63EXJ5RCWWDO726"
}
```

- `typ` is the type of payload encoded
- `alg` specifies the algorithm used to secure the JWS. 
  - `EdDSA` stands for Edwards-curve Digital Signature Algorithm and is the same algorithm used for Stellar keypairs. 
  - Using the same algorithm allows signing servers to use the keypair specified by their [stellar.toml](sep-0001.md)'s `SIGNING_KEY` to sign the JSON-encoded objects described here. 
- `kid` is the Key Id (stellar public key) used to sign the JWS.

The second JSON object is a JWS Payload. In this case, we'll use a [JWT](http://www.rfc-editor.org/info/rfc7519) containing members similar to the [claims](https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1) described in SEP-10:

```json
{
    "iss": "https://walletsigningserver.com",
    "sub": "GALWLDCKL5FJTBGRB2KXVHNXDQTE422YD7U6EULR7PSZ2OXPTJ3WHTLU",
    "jti": "aa77983a-e550-4d90-8cc2-d661d7f0b8f6",
    "kid": "GCR5WQYXYT4ECBQ3SBALXHICPEVTWKY75XKKZ3ZMF63EXJ5RCWWDO726",
    "aud": "https://anchorserver.com",
    "exp": "1597789801",
    "iat": "1597703375"
}
```

* `iss` — the fully qualified URL of the home domain for the signing server issuing the token
* `sub` - the stellar account address of the user requesting the transaction
* `jti` — the identifier for the transaction being processed by the client and defined by the anchor
* `kid` - the stellar public key address used to sign the JWS
* `aud` - the fully qualified URL of the home domain for the anchor server receiving the token
* `iat` - the [timestamp](https://tools.ietf.org/html/rfc7519#section-4.1.6) for the time this token was issued
* `exp` - the [timestamp](https://tools.ietf.org/html/rfc7519#section-4.1.4) for the time on or after which the JWT must not be accepted for processing

The two JSON objects should be base64-encoded and concatenated with a `.` character. 
```
eyJhbGciOiJFZERTQSJ9
.
eyJhdWQiOiJodHRwczovL2FuY2hvcnNlcnZlci5jb20iLCJleHAiOiIxNTk3Nzg5ODAxIiwiaWF0IjoiMTU5NzcwMzM3NSIsImlzcyI6Imh0dHBzOi8vd2FsbGV0c2lnbmluZ3NlcnZlci5jb20iLCJqdGkiOiJhYTc3OTgzYS1lNTUwLTRkOTAtOGNjMi1kNjYxZDdmMGI4ZjYiLCJzdWIiOiJHQ0NYS0NIVkVESDZNR1pZSUhER0lGRDVMSEdEM1JDQVo3TkZMSUFZNk5aQ0ZZQlZTNk1RUEZSNyJ9
```

The resulting string should then be signed by the server's JSON Web Key (JWK). JWK's can be constructed by using the Stellar public and private keys used by client.

Stellar keypairs use their encoding and representation, but can be decoded and encoded again in base64 to get the values necessary from the public and secret keys. You'll likely use an SDK to extract the raw bytes used to encode a Stellar public and private key. In JavaScript, this may look something like this:
```javascript
> const StellarSDK = require('stellar-sdk');
undefined
> const kp = StellarSDK.Keypair.random();
undefined
> kp
Keypair {
  type: 'ed25519',
  _secretSeed: <Buffer 21 a1 e7 a5 53 2f 18 05 75 b3 3c 87 b6 1d 4d 2a e6 28 0f 88 da 92 27 d9 20 8d 0e 94 9f 90 58 94>,
  _publicKey: <Buffer b1 b2 6e b6 fc 44 74 bd 6f 69 14 52 91 d7 c7 ca c6 1d 9b 7d 52 8d 9c c2 ac 5e f9 61 07 28 e4 40>,
  _secretKey: <Buffer 21 a1 e7 a5 53 2f 18 05 75 b3 3c 87 b6 1d 4d 2a e6 28 0f 88 da 92 27 d9 20 8d 0e 94 9f 90 58 94 b1 b2 6e b6 fc 44 74 bd 6f 69 14 52 91 d7 c7 ca c6 1d ... 14 more bytes>
}
> 
```

The `Buffer` objects for the `_secretSeed` and `_publicKey` contain the hex-encoded bytes of the stellar keys. Encoding these bytes in base64 produce the inputs required to generate a JWK.

For example, the python implementation may look something like this:
```python
import codecs
from stellar_sdk import Keypair
from jwcrypto import jwk, jwt

# the client's SIGNING_KEY keypair
kp = Keypair.random()

# The first two pieces of the JWS
jws = jwt.JWT(
    header={"alg": "EdDSA", "typ": "EdDSA", "kid": kp.public_key},
    claims={
        "iss": "https://walletsigningserver.com",
        "sub": "GALWLDCKL5FJTBGRB2KXVHNXDQTE422YD7U6EULR7PSZ2OXPTJ3WHTLU",
        "jti": "aa77983a-e550-4d90-8cc2-d661d7f0b8f6",
        "kid": "GCR5WQYXYT4ECBQ3SBALXHICPEVTWKY75XKKZ3ZMF63EXJ5RCWWDO726",
        "aud": "https://anchorserver.com",
        "exp": "1597789801",
        "iat": "1597703375"
    }   
)

# The base64-encoded public and secret keys
# Stellar uses its own representation, so we use the raw bytes
public_key_encoded = codecs.encode(kp.raw_public_key(), "base64")
secret_key_encoded = codecs.encode(kp.raw_secret_key(), "base64")

# the JWK used to sign the token
key = jwk.JWK(
    kty="OKP",
    crv="Ed25519",
    x=public_key_encoded,
    d=secret_key_encoded,
)
jws.make_signed_token(key)
print(jws.serialize())
```

The resulting string will look something like this:
```
eyJhbGciOiJFZERTQSJ9
.
eyJhdWQiOiJodHRwczovL2FuY2hvcnNlcnZlci5jb20iLCJleHAiOiIxNTk3Nzg5ODAxIiwiaWF0IjoiMTU5NzcwMzM3NSIsImlzcyI6Imh0dHBzOi8vd2FsbGV0c2lnbmluZ3NlcnZlci5jb20iLCJqdGkiOiJhYTc3OTgzYS1lNTUwLTRkOTAtOGNjMi1kNjYxZDdmMGI4ZjYiLCJzdWIiOiJHQ0NYS0NIVkVESDZNR1pZSUhER0lGRDVMSEdEM1JDQVo3TkZMSUFZNk5aQ0ZZQlZTNk1RUEZSNyJ9
.
xZi9TX_KI9sXA1XJlm_O5t6FLxs0sx9suBf5Kv4SVqL8Glo_zL4EbPZ6SgjeqBd31xnVQ-b5q4rwpiPIz278AQ
```

The public key used to generate the third part of the JWS can also be used to verify the integrity of the first and second part. This is what the anchor server would do when a wallet makes a request containing the JWS token. 

## Verifying Requests
Other proposals will specify how the JWS returned by the wallet's signing server should be sent to the anchor server. The anchor can keep the public keys of known wallet signing servers, but if the client is unknown, the anchor should request the signing server's [stellar.toml](sep-0001.md) and validate that the value found was used to encrypt the JWS.

Wallet signing servers could also rotate their `SIGNING_KEY`. Anchors receiving JWS tokens from these clients may have to update their local copies of the wallets' public keys.

Once verified, the anchor server can use the JWT attributes with confidence that the integrity of the data has been maintained and that the wallet requesting the transaction and passing the JWS belongs to the wallet's signing server.

### Expiration
Signing servers should select an expiration time for the JWT that is appropriate for the assumptions and risk of the interactions a user can perform with it. A client may own a transaction at the time the JWT is issued but they may not at some point in the future. 

Expiration times that are too long increase the risk that control of the transaction request will change. Expiration times that are too short increase the number of times authentication must reoccur, and a user using a hardware signing device or who must complete a complex signing process could have a poor user experience.
