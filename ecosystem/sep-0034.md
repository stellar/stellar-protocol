## Preamble

```
SEP: To Be Assigned
Title: Client Application Attribution
Author: Jake Urban, Leigh McCulloch
Track: Standard
Status: Draft
Created: 2020-08-17
Discussion: https://github.com/stellar/stellar-protocol/issues/685
```

## Simple Summary
This protocol outlines how a client can prove to a web server that the application requesting the relevant operation is owned by the client.

## Motivation
In general, web services may want to attribute incoming requests to client applications on a per-operation basis. Because requests headers like `User-Agent` can be spoofed, anchors require a cryptographically secure method of verifying a client's identity.

For example, an anchor server may not charge fees for transactions created using a particular wallet. In this case, the operation is processing a deposit or withdrawal transaction, but the operation could be any action related to different use cases.

## Abstract
This following protocol involves 3 parties:

- the client application: the party requesting an operation from the attribution server 
- the client's signing server: the web server that claims ownership of the client application
- the attribution server: the web server that verifies the signing server's claims

At a high level, the signing server generates a [JSON Web Signature](https://www.rfc-editor.org/rfc/rfc7515.html) (JWS) that the client receives and includes in future requests to the attribution server. The attribution server verifies that the token included in the request was signed by the signing server, proving that the signing server takes ownership for the client requesting the operation from the verfication server.

How the client application communicates with the signing server and receives the JWS is out of the scope of this document. The only requirement is for the signing server to return a JWS in the format descibed in the next section.

## Token

The JWS can be generated using two JSON objects and a secret if the HMAC SHA-256 algorithm is used.

The first JSON object is the [JWS Protected Header](https://www.rfc-editor.org/rfc/rfc7515.html#section-4):
```json
{
    "typ": "JWT",
    "alg": "HS256",
}
```

`typ` is the type of payload encoded and `alg` specifies the algorithm used to secure the JWS.

The second JSON object is a JWS Payload. In this case, we'll use a [JWT](http://www.rfc-editor.org/info/rfc7519) containing members similar to the [claims](https://www.rfc-editor.org/rfc/rfc7519.html#section-4.1) described in SEP-10:

```json
{
    "iss": "https://attributionserver.com",
    "sub": "aa77983a-e550-4d90-8cc2-d661d7f0b8f6",
    "exp": "1597789801",
    "iat": "1597703375"
}
```

* `iss` (the principal that issued a token, [RFC7519, Section 4.1.1](https://tools.ietf.org/html/rfc7519#section-4.1.1)) — a [Uniform Resource Identifier (URI)] for the issuer (`https://example.com` or `https://example.com/G...`)
* `sub` (the principal that is the subject of the JWT, [RFC7519, Section 4.1.2](https://tools.ietf.org/html/rfc7519#section-4.1.2)) — the `operation_id` being processed by the client
* `iat` (the time at which the JSW was issued [RFC7519, Section 4.1.6](https://tools.ietf.org/html/rfc7519#section-4.1.6)) — current timestamp (`1530644093`)
* `exp` (the expiration time on or after which the JWT must not be accepted for processing, [RFC7519, Section 4.1.4](https://tools.ietf.org/html/rfc7519#section-4.1.4)) — a server can pick its own expiration period for the token (`1530730493`)

Finally, the two JSON objects should be base64-encoded and concatenated with a `.` character. The resulting string should then be encrypted using a signing key, and the encrypted string should
be appended to the end of the unencrypted string, again including a `.` character.
```
eyJ0eXAiOiAiSldUIiwiYWxnIjogIkhTMjU2In0
.
eyJpc3MiOiAiaHR0cHM6Ly9hbmNob3Jkb21haW4uY29tL2F0dHJpYnV0aW9uIiwic3ViIjogImFhNzc5ODNhLWU1NTAtNGQ5MC04Y2MyLWQ2NjFkN2YwYjhmNiIsImV4cCI6ICIxNTk3Nzg5ODAxIiwiaWF0IjogIjE1OTc3MDMzNzUifQ
.
mEUU0apnMrlwiNER-Wac6F5xuXDWuZjAsmqy7Ap02C4
```

The signing key used to generate the third part of the JWS can also be used to verify it. 

## Verifying Requests
Other proposals will specify how the JWS returned by the client's signing server should be sent to the attribution server. Once sent, the attribution server should check the signing server's [stellar.toml](sep-0001.md) for a `SIGNING_KEY` variable and validate that the value found was used to encrypt the JWS. 

The attribution server can save the keys of known clients so it doesn't have to collect it from the signing server unless the initial verification fails. This may happen if the attribtion server rotates their `SIGNING_KEY`.

Once verified, the attribution server can use the attributes encoded in the unprotected portions of the JWS with confidence that the integrity of the data has been maintained and that the client processing the requested operation and passing the JWS belongs to the signing server.

### Expiration
Signing servers should select an expiration time for the JWT that is appropriate for the assumptions and risk of the interactions a user can perform with it. A client may own an operation at the time the JWT is issued but they may not at some point in the future. 

Expiration times that are too long increase the risk that control of the operation. Expiration times that are too short increase the number of times authentication must reoccur, and a user using a hardware signing device or who must complete a complex signing process could have a poor user experience.