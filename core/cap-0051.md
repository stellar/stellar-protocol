```
CAP: 0050
Title: Smart Contract Host Functionality: Secp256r1 Verification
Working Group:
    Owner: Leigh McCulloch <@leighmcculloch>
    Authors: Leigh McCulloch <@leighmcculloch>
    Consulted: Graydon Hoare <@graydon>, Riad S. Wahby <@kwantam>
Status: Draft
Created: 2023-01-30
Discussion: https://discord.com/channels/897514728459468821/1199160204676300841
Protocol version: TBD
```

## Simple Summary

Support secp256r1 verification in Soroban contracts via the exported host
interface.

## Motivation

Secp256r1, also commonly known as prime256r1 or ecdsa p256, is a common elliptic
curve used with ecdsa. It's one of the common signature algorithms used in
webauthn, which is the standard behind passkeys available on, browsers,
computers, and phones. Supporting secp256r1 natively would allow for the
execution of efficient webauthn implementations where-by browsers, computers,
and phones could be the signers of accounts on Stellar via Soroban's custom
account interface. While it is possible to embed ecdsa secp256r1 verification
into contracts on the guest side, the instruction cost of ecdsa verification is
greater than the networks current maximum limits.

### Goals Alignment

This CAP is aligned with the following Stellar Network Goals:

- The Stellar Network should make it easy for developers of Stellar projects to
  create highly usable products

## Abstract

One function `verify_sig_ecdsa_secp256r1` is added to the Soroban environment's
exported function interface that accepts the parameters needed to verify a
secp256r1 signature of a payload for a public key.

## Specification

### XDR Changes

None.

### Host Function Changes

```diff mddiffcheck.ignore=true mddiffcheck.base=v20.1.0
diff --git a/soroban-env-common/env.json b/soroban-env-common/env.json
index df7d5c4..32cd1c3 100644
--- a/soroban-env-common/env.json
+++ b/soroban-env-common/env.json
@@ -1958,6 +1958,26 @@
           ],
           "return": "BytesObject",
           "docs": "Recovers the SEC-1-encoded ECDSA secp256k1 public key that produced a given 64-byte signature over a given 32-byte message digest, for a given recovery_id byte."
+        },
+        {
+          "export": "3",
+          "name": "verify_sig_ecdsa_secp256r1",
+          "args": [
+            {
+              "name": "public_key",
+              "type": "BytesObject"
+            },
+            {
+              "name": "message",
+              "type": "BytesObject"
+            },
+            {
+              "name": "signature",
+              "type": "BytesObject"
+            }
+          ],
+          "return": "Void",
+          "docs": "Verifies that the signature of the message was produced using the secret key of the public key."
         }
       ]
     },
```

### Semantics

#### Host Function Changes

A function is added to the host interface for verifying ecdsa secp256r1 signatures.

The interface of the function is different to the existing ecdsa secp256k1 interface because the latter is a recovery interface that recovers a public key given a message, signature, and a recovery ID.

The secp256r1 interface is proposed as a verification interface accepting a public key, message, and signature, because the majority of existing signing software and hardware that support ecdsa secp256r1 do not provide the recovery ID.

To support a recovery interface for secp256r1 the Soroban environment could
perform two recoveries, one with recovery ID 0 and again with recovery ID 1, to
determine all possible matching public keys. Doing so would require two rounds
of recovery and the operations and since the operations take up to 2ms each it
would not be acceptable to do twice.

Alternatively, it would be possible for off-network software to take an ecdsa
public key, message, and signature and derive the recovery ID by performing one
to two verifications off-network. Doing so would require that all clients embed
ecdsa secp256r1 recovery implementations which are not common in non-blockchain
systems, such as browsers or phones implementing webauthn/passkeys.

A motivation to use the alternative recovery interfaces is that it will likely
that contract that use secp256r1 verification will store a public key on chain,
or communicate the public key in invocation arguments. In both cases a
verification interface will require transmission and storage of the full 65-byte
public key. A recovery interface would allow for hashing and truncating the
transmitted or stored public key to 32-bytes if hashed with SHA-256, or 20-bytes
if hashed and truncated similar to how Ethereum addresses are produced. This
space reduction would lower the read/write resource usages as well as
transactions size, for an increase in instruction cost.

## Protocol Upgrade Transition

### Backwards Incompatibilities

This proposal is completely backwards compatible.

### Resource Utilization

An ecdsa secp256r1 verification takes approximately 2ms in current tests. It
would be appropriate metered.

### Security

The only secp256r1 pure-Rust crate that the Soroban environment could embed is
the [p256] and [ecdsa] crates. The two crates have never been independently
audited.

## Test Cases

None yet.

## Implementation

None yet. But will be tracked by [stellar/rs-sorovan-env#807] if implemented.

[p256]: https://crates.io/crates/p256
[ecdsa]: https://crates.io/crates/ecdsa
[stellar/rs-soroban-env#807]: https://github.com/stellar/rs-soroban-env/issues/807
