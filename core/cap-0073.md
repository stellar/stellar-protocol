```
CAP: 0073
Title: Allow SAC to create G-account balances
Working Group:
    Owner: Dmytro Kozhevin <@dmkozh>
    Authors: Dmytro Kozhevin <@dmkozh>
    Consulted: Leigh McCulloch <@leighmcculloch>
Status: Draft
Created: 2025-09-18
Discussion: https://github.com/orgs/stellar/discussions/1668
Protocol version: TBD
```

## Simple Summary

Add Stellar Account contract (SAC) functions for managing trustlines of Stellar (G-)accounts and create new G-accounts on XLM transfer.

## Working Group

As specified in the Preamble.

## Motivation

Stellar Asset contract allows moving the Stellar assets between any accounts (both classic G-accounts and custom C-accounts), but Soroban doesn't provide a way to create a new G-account balance. This behavior is not consistent with the contract (C-)accounts, for which the balances are created automatically on the first transfer.

The feature imparity is tolerable to some degree, because a G-account can create a trustline via a classic operation, and a new G-account itself can be created via a separate operation. While the workaround provides a way for using SAC for G-accounts after some 'classic'-side setup, it comes with some issues, such as:

- It's not possible to create an trustline and perform a SAC transfer to it atomically as classic operations can't be mixed with Soroban operations
- It's tricky for Soroban-based apps to provide programmatic support for the missing trustlines, as bespoke processing is necessary. The 'simplest' option is to bubble up the error and ask the user to establish a trustline, and even that is not trivial to support
- With [CAP-72](./cap-0072.md) G-accounts will be allowed to have C-account delegated signers available *only* for Soroban invocations. Inability to establish trustlines from Soroban means that the users won't be able to perform some Soroban interactions using just their C-account keys, which is inconsistent with the C-accounts that can perform any Soroban interaction

By allowing the trustline and account creation from within Soroban the protocol will resolve these feature gaps and improve the user and developer experience for any use case that needs to deal with SAC.

### Goals Alignment

This CAP is aligned with the following Stellar Network Goals:

  - The Stellar Network should make it easy for developers of Stellar projects to create highly usable products

## Abstract

This CAP introduces two new Stellar Asset contract functions for the trustline management. The new `change_trust` function manages the G-account trustline in the same fashion as the existing `ChangeTrustOp`, while `has_trust` allows to programmatically determine if an address has a trustline at all, which supports smart-contract driven trustline management.

This also updates the `transfer` and `transfer_from` functions specifically for the 'native' asset (i.e. for the XLM SAC). When an XLM transfer is coming to a G-address that doesn't have a corresponding account entry yet, the account will be created as long as the transfer amount covers the minimum allowed account balance.

## Specification

### New SAC functions

The following new functions are added to the Stellar Asset contract:

```rust
/// Updates this contract asset's trustline for the provided G-address.
///
/// This has to authorized by the `address` (`address.require_auth` is called).
///
/// When the limit is greater than zero, creates a new trustline or updates the
/// limit on the trustline.
///
/// If the limit is zero, removes the existing trustline.
///
/// Panics if the asset issuer does not exist, address is not a G-address, the
/// limit is below the allowed minimum, or when a new trustlines can not be
/// created.
fn change_trust(env: Env, address: Address, limit: i64);

/// Returns `true` if the provided address trusts this contract's asset.
///
/// This always returns `true` for the C-addresses, and is `true` for any
/// G-address that has a trustline for this contract's asset.
///
/// Note, that having trust for the asset is a necessary, but not a sufficient,
/// condition for an `Address` to be able to take part in any token operations,
/// including receiving the incoming transfers. There are other factors that
/// might make receiving the incoming transfers impossible, such as lack of
/// authorization (verified with `authorized` function), or too low trustline
/// limit.
fn has_trust(env: Env, address: Address) -> bool;
```

### Semantics

#### `change_trust` function

`change_trust` SAC function has similar semantics to the existing `ChangeTrustOp`, with some Soroban-specific details:

- The asset for which the trustline is managed is implied by the SAC instance `change_trust` is called for instead of being provided explicitly
  - Thus, unlike for `ChangeTrustOp`, only the regular `Asset` trustlines can be modified, as liquidity pool shares don't have a SAC associated with them
- `require_auth` is called to perform `address` authorization, which means that all the Soroban auth features are available
- Input `address` can be a C-address, but passing it is an error and results in panic
- Sponsorship is not supported for creating a new trustline, so the address must have sufficient XLM balance in order to be able to create a new trustline

Besides these differences, the semantics are directly translated from `ChangeTrustOp`. Here is a quick summary:
- The limit can not be lower than the minimum allowed by the protocol, specifically lower than the buying liabilities, the function panics otherwise
- If the asset issuer does not exist, the function panics
- If trustline does not exist, it is created
  - This increases the number of sub-entries (and thus base reserve) of the account that owns the trustline and thus is subject to the existing protocol limitations for creating the classic sub-entries
  - Sponsorship is not compatible with Soroban and thus base reserve may only belong to the trustline owner
- If limit is `0` and the trustline exists, the trustline is removed
  - This reduces the number of sub-entries (and thus the base reserve) of the account that owns the trustline, or, in case of a sponsored trustline, updates the sponsorship accordingly
- Create a trustline to account's own asset will result in panic  

#### `has_trust` function

`has_trust` SAC function is a read-only function that tells if a G-account has an existing trustline. For C-accounts this always returns `true`.

This function does not require any authorization.

#### XLM transfer creates `AccountEntry`

When an XLM transfer is performed to a G-address that does not exist yet (i.e. it does not have a respective `AccountEntry`), Soroban host will attempt to create a new `AccountEntry` for it. Specifically, it will create a new `AccountEntry` with the full transfer amount as balance if the transfer amount is at least the minimum account balance (1 XLM as of this CAP). Otherwise, it will panic.

This change affects both SAC functions that perform transfers: `transfer` and `transfer_from`.

The newly created account will immediately become available to interact with, including using it to perform authorization via `require_auth` and using it as a built-in contract as defined by [CAP-72](./cap-0072.md).

## Design Rationale

### Account base reserve management from Soroban

This CAP introduces a way to create and remove the classic trustline entries from Soroban. Most of the design coincide with those for the G-account signer management in [CAP-72](./cap-0072.md#account-base-reserve-management-from-soroban). Signers could in theory be stored in a contract data entry and that would require a relatively small amount of changes. However, if Soroban created trustlines only as contract data entries, then almost every classic operation would need to be modified to account for these entries. Thus, that alternative is even less feasible than in the case of CAP-72.

### `has_trust` function vs automatic trustline creation

Transfers to accounts without a trustline could initiate trustline creation in a similar fashion to the account entry creation in case of XLM SAC. However, that would likely result in confusing user experience:

- An additional signature from the transfer _receiver_ would be required (in order to approve the trustline creation). It's not generally expected for the transfer to expect the receiver signature, and that scenario would also happen very rarely in a general case, so there is a high chance for developers to miss it
- It is not clear what the trustline limit should be. Limiting it to the transfer amount seems overly restrictive, but setting it to the maximum possible value may not be desired in some edge cases.

`has_trust` function allows contract developers to easily check in their contract if trustline creation is necessary without trying to modify the trustline limit unconditionally (and thus always requiring the receiver signature every time). It also requires a conscious effort to support the trustline creation behavior, which reduces the chance of the additional required signature payload to go unnoticed. Lastly, it also solves the default limit issue for the most part, as an explicit `change_trust` still has to be made.

### `has_trust` function granularity

Following the logic above we could come up with a function that returns more granular information about the trustline, such as the current limit, or the minimum limit necessary for the receiver to be able to receive the balance. The less granular option is chosen as it's simple and straightforward.

Over the last year over 98% of the active trustlines had limit over 1e18 (effectively unlimited, 95+% of trustlines are also at int64 max), so a boolean getter is going to be sufficient most of the time. For the remaining small amount of cases, it is not likely that there is a good generalized approach to managing the exact trustline limit on the contract side, so it's not obvious that a more granular getter would actually end up being useful.

### Backwards Incompatibilities

This CAP does not introduce backward incompatibilities.

### Resource Utilization

The new contract functions will have the appropriate metering. No new cost types need to be introduced, as the operations can lean on the existing metering primitives.

## Security Concerns

## Test Cases

TBD

## Implementation

TBD

