```
CAP: 0072
Title: Contract signers for Stellar accounts
Working Group:
    Owner: Dmytro Kozhevin <@dmkozh>
    Authors: Dmytro Kozhevin <@dmkozh>
    Consulted: Leigh McCulloch <@leighmcculloch>, Nicolas Barry <@MonsieurNicolas>, Anup Pani <@anupsdf>
Status: Draft
Created: 2025-09-04
Discussion: https://github.com/orgs/stellar/discussions/1763
Protocol version: TBD
```

## Simple Summary

Provide protocol tools for customizing authentication logic for the Stellar (G-) accounts via smart contracts.

## Working Group

As specified in the Preamble.

## Motivation

Contract (C-) accounts on Stellar are fully customizable, but wallets get access to more of the ecosystem today with a G-account.

One type of functionality that some wallets want to adopt is passkeys, and specifically, the recovery processes available to passkeys on modern phones where they can be backed up in the cloud. However, to adopt passkeys is to adopt a contract account and step away from everything the ecosystem has only for G-accounts.

There is a wide range of possible solutions for bridging the gap between the C- and G-accounts, with different degree of complexity and technical challenges. This CAP aims at reducing the complexity by focusing on the specific issue of G-account customization for limited use cases and providing a solution that addresses this issue, but not necessarily more. For example, it's not a goal for this CAP to solve the issue of not being able to pay fees using contract-based authentication.

### Goals Alignment

This CAP is aligned with the following Stellar Network Goals:

  - The Stellar Network should make it easy for developers of Stellar projects to create highly usable products

## Abstract

This CAP introduces a new kind of G-account signers that are accessible only from within the smart contract environment called 'delegated signers'. Delegated signers have a signature weight, similarly to the existing ed25519 account signers. Instead of performing the cryptographic verification, `require_auth` host function will be called for the delegated signer's address in order to perform authentication. Thus, if the delegated signer is a contract, then `__check_auth` will be called for it, which allows for the G-account authentication customization.

Since delegated signers are only accessible in the smart contract environment, in order to fulfill the account management requirement, every G-account is treated as a built-in smart contract with an interface that provides all the account management capabilities necessary for the recovery flows. Unlike the Stellar Asset contract, every account on chain will be implicitly instantiated as a contract, i.e. its address will just become callable without any additional actions required from the users.

When managing the G-account via contract functions the new data will be written to a special new 'additional signers' contract data entry, while the modifications and deletions can happen both in the 'additional signers' entry and in the `AccountEntry` itself.

Delegated signers are not allowed to sign the transactions. However, the protocol will allow using ed25519 account signers that come from the 'additional signers' contract data entry. This way it will be possible to recover full access to the account from the built-in contract, including the ability to sign transactions.

Additional account signers are stored in a contract data entry and thus it may be archived. Protocol will still allow to sign transactions with the signers that remain in the account entry, but account merges will only be allowed after the 'additional signers' entry has been restored.

## Specification

### XDR changes

This patch of XDR changes is based on the XDR files in commit `4b7a2ef7931ab2ca2499be68d849f38190b443ca` of stellar-xdr.

```diff mddiffcheck.ignore=true
diff --git a/Stellar-contract.x b/Stellar-contract.x
index 0e67dc3..1845616 100644
--- a/Stellar-contract.x
+++ b/Stellar-contract.x
@@ -63,14 +63,20 @@ enum SCValType
     SCV_ADDRESS = 18,
 
     // The following are the internal SCVal variants that are not
-    // exposed to the contracts. 
+    // exposed to the contracts.
+
+    // A special value type for holding contract instance data.
     SCV_CONTRACT_INSTANCE = 19,
 
     // SCV_LEDGER_KEY_CONTRACT_INSTANCE and SCV_LEDGER_KEY_NONCE are unique
     // symbolic SCVals used as the key for ledger entries for a contract's
     // instance and an address' nonce, respectively.
     SCV_LEDGER_KEY_CONTRACT_INSTANCE = 20,
-    SCV_LEDGER_KEY_NONCE = 21
+    SCV_LEDGER_KEY_NONCE = 21,
+
+    // A special value type for holding additional signers of a Stellar account 
+    // as contract data.
+    SCV_ACCOUNT_SIGNERS = 22
 };
 
 enum SCErrorType
@@ -226,6 +232,30 @@ struct SCContractInstance {
     SCMap* storage;
 };
 
+enum SCAccountSignerType
+{
+    ACCOUNT_SIGNER_CLASSIC = 0,
+    ACCOUNT_SIGNER_DELEGATED = 1
+};
+
+struct SCDelegatedAccountSigner {
+    SCAddress address;
+    uint32 weight;
+};
+
+union SCAccountSigner switch (SCAccountSignerType type)
+{
+case ACCOUNT_SIGNER_CLASSIC:
+    Signer signer;
+case ACCOUNT_SIGNER_DELEGATED:
+    SCDelegatedAccountSigner delegatedSigner;
+};
+
+struct SCAccountSigners {
+    ExtensionPoint ext;
+    SCAccountSigner signers<MAX_SIGNERS>;
+};
+
 union SCVal switch (SCValType type)
 {
 
@@ -285,6 +315,8 @@ case SCV_LEDGER_KEY_CONTRACT_INSTANCE:
     void;
 case SCV_LEDGER_KEY_NONCE:
     SCNonceKey nonce_key;
+case SCV_ACCOUNT_SIGNERS:
+    SCAccountSigners signers;
 };
 
 struct SCMapEntry
diff --git a/Stellar-ledger-entries.x b/Stellar-ledger-entries.x
index b9a9a16..7deba93 100644
--- a/Stellar-ledger-entries.x
+++ b/Stellar-ledger-entries.x
@@ -124,12 +124,18 @@ enum AccountFlags
     // Trustlines are created with clawback enabled set to "true",
     // and claimable balances created from those trustlines are created
     // with clawback enabled set to "true"
-    AUTH_CLAWBACK_ENABLED_FLAG = 0x8
+    AUTH_CLAWBACK_ENABLED_FLAG = 0x8,
+
+    // General purpose flags
+    // Indicates that an account has a contract data entry with additional 
+    // signers.
+    ACCOUNT_ADDITIONAL_SIGNERS_ENTRY_FLAG = 0x10,
 };
 
 // mask for all valid flags
 const MASK_ACCOUNT_FLAGS = 0x7;
 const MASK_ACCOUNT_FLAGS_V17 = 0xF;
+const MASK_ACCOUNT_FLAGS_V24 = 0x1F;
 
 // maximum number of signers
 const MAX_SIGNERS = 20;
diff --git a/Stellar-transaction.x b/Stellar-transaction.x
index 9a14d6e..53a74e1 100644
--- a/Stellar-transaction.x
+++ b/Stellar-transaction.x
@@ -1478,7 +1478,10 @@ enum AccountMergeResultCode
     ACCOUNT_MERGE_SEQNUM_TOO_FAR = -5,  // sequence number is over max allowed
     ACCOUNT_MERGE_DEST_FULL = -6,       // can't add source balance to
                                         // destination balance
-    ACCOUNT_MERGE_IS_SPONSOR = -7       // can't merge account that is a sponsor
+    ACCOUNT_MERGE_IS_SPONSOR = -7,      // can't merge account that is a sponsor
+    // There is an additional signers entry for this account that has been 
+    // archived. It has to be restored first before account can be merged.
+    ACCOUNT_MERGE_ADDITIONAL_SIGNERS_ARCHIVED = -8 
 };
 
 union AccountMergeResult switch (AccountMergeResultCode code)
```

### Stellar(G-) account contract interface

This CAP introduces a callable smart contract interface for the Stellar accounts. The following Rust trait specifies the interface as Soroban Rust SDK contract.

```rust
pub trait StellarAccountInterface {
    /// Adds a new ed25519 signer to the account with the given weight, or
    /// updates the weight if the signer already exists.
    /// 
    /// Weight must be in range (0, 255].
    fn update_ed25519_signer(env: Env, key: BytesN<32>, weight: u32);

    /// Removes an ed25519 signer from the account.    
    fn remove_ed25519_signer(env: Env, key: BytesN<32>);

    /// Adds a new delegated signer to the account with the given weight, or
    /// updates the weight if the signer already exists.
    /// 
    /// Weight must be in range (0, 255].
    ///
    /// Instead of performing signature verification for the delegated signers,
    /// their authentication logic (`__check_auth`) will be called instead via
    /// `delegate_account_auth` host function.
    fn update_delegated_signer(env: Env, signer: Address, weight: u32);

    /// Removes a delegated signer from the account.
    fn remove_delegated_signer(env: Env, signer: Address);

    /// Sets the weight for the 'master' key of the account.
    /// 
    /// The 'master' key is the public ed25519 key that identifies the account
    /// itself. Setting the weight to 0 effectively removes the master key
    /// from the account.
    fn set_master_weight(env: Env, weight: u32);

    /// Updates the signature thresholds for the account.
    /// 
    /// `None` values leave the corresponding threshold unchanged.
    /// 
    /// `low` threshold is only used for authorizing a few non-sensitive Stellar
    //  operations, such as bumping the account's sequence number.
    /// 
    /// `med` threshold is used for authorizing most of the operations, 
    /// including the Smart Contract interactions authorized via `require_auth`.
    /// 
    /// `high` threshold is used for managing the account itself. Note, that
    /// all the functions in this interface require high threshold, while still
    /// being authorized via `require_auth`.
    fn update_thresholds(env: Env, low: Option<u32>, med: Option<u32>, high: Option<u32>);
}
```

### 'Classic' transaction semantics

#### Ledger entry for additional account signers

Every new or existing G-account on-chain may have up to 1 `ContractDataEntry` that contains additional signers (further referred to as 'additional signers entry'). The specification for the entry is as follows:

- `contract` - the `SCAddress` corresponding to the account
- `key` - `SCV_SYMBOL` `SCVal` with value `"SIGNERS" `
- `durability` - `PERSISTENT`
- `val` - `SCV_ACCOUNT_SIGNERS` `SCVal`

`SCAccountSigners` payload may contain up to `MAX_SIGNERS` additional signers of type `SCAccountSigner` for the account (where `MAX_SIGNERS` is the same constant as one used for the `AccountEntry`, currently set to `20`). This new value type is introduced in the XDR changes above.

`SCAccountSigner` may represent either a 'classic' account signer of type `Signer` (the same type as the one used for the `AccountEntry` itself), or a new kind of signer - `SCDelegatedAccountSigner`. For the `Signer` kind of signers only keys of type `SIGNER_KEY_TYPE_ED25519` will be allowed as of this CAP.

`SCDelegatedAccountSigner` contains only an address to require authorization from and its weight. The maximum supported weight is 255, the same as the maximum weight for any other signer type.

When the additional signers entry is created, the account flag `ACCOUNT_ADDITIONAL_SIGNERS_ENTRY_FLAG` is set to 1, and when the entry is removed, the flag is set to 0. The flag can be used by the protocol for optimizing the account signer lookup, as well as for the downstream consumers for the purpose of account fetching and audit.

#### Transaction signature verification rules update

Transaction signature verification rules are updated to account for the additional account signers entry.

When performing transaction or operation signature validation for a given G-account, account signers will be loaded from both the corresponding `AccountEntry` and the corresponding *live* additional signers entry when `ACCOUNT_ADDITIONAL_SIGNERS_ENTRY_FLAG` is set. Only signers of type `ACCOUNT_SIGNER_CLASSIC` will be loaded. 

If additional signers entry is not in the live state, then the signers will be treated as non-existent until the additional signers entry has been restored, so the transactions using such signers will be considered invalid. The error returned in that scenario is `txBAD_AUTH`. Clarifying message specifying that the additional signers entry is archived will be written into the diagnostic events when transaction is rejected on submission.

#### Account merge operation update

Account merges have to completely clean up the account state. Thus, the additional signers entry will be removed as a part of the account merge operation.

In case if the additional signers entry is not in the live state, account merge operation will fail at apply time. The check for entry being live should only be performed when `ACCOUNT_ADDITIONAL_SIGNERS_ENTRY_FLAG` is set, so there is no need to ever lookup the Hot Archive or potentially require non-existence proofs in the future protocols.

`ACCOUNT_MERGE_ADDITIONAL_SIGNERS_ARCHIVED` operation error will be returned if the additional signers entry is archived.

### Smart contract semantics

#### G-account authentication

The algorithm for verifying detached (non-`SOURCE_ACCOUNT`) smart contract authorization in Soroban host is updated to account for the additional signers, as well as to enable delegated account support.

Similarly to the transaction signature verification rules update, account signers will be loaded both from the `AccountEntry` and the additional signers entry when `ACCOUNT_ADDITIONAL_SIGNERS_ENTRY_FLAG` is set. The authentication logic is not changed for the 'classic' signers (`ACCOUNT_SIGNER_CLASSIC`). For the delegated signers, `delegate_account_auth` will be called with the corresponding delegated signer address and handled as per the section above.

The signer weight processing remains unchained, but the weights may come from any account signer

An additional change is made in order to use the proper signature threshold for the account management. Currently, G-account authentication rules in Soroban use `MEDIUM` threshold when authenticating an account for any Soroban operation, i.e. the built-in G-account contract ignores the authorization context completely.

With this CAP, if any contract call on a G-account is present in authorization context, then the threshold requirement will be raised to `HIGH`.

#### G-account contract (GAC)

Every G-account on-chain gets an implicit contract 'instance' which is just represented by the account entry itself. The contract will be called GAC further for simplicity.

When a contract call is performed on a G-address, the implementation of GAC built into host will handle the call. This is similar to the Stellar Asset contract handling (SAC), with the only difference being that a non-contract address is being used for routing the calls.

When GAC functions add new signers, the new signers are written to the additional signers contract data entry. The entry will be created in case if it didn't exist before, or removed when there are no additional signers remaining.

Every GAC function calls `require_auth` for the corresponding G-account. Authentication procedure will require `HIGH` signature threshold, as per G-account authentication semantics described above.

The following sections describe semantics of all the GAC functions.

##### `update_ed25519_signer`

Adds a new ed25519 signer with the provided 32-byte public key and the provided weight to the additional signers entry as `ACCOUNT_SIGNER_CLASSIC` signer. If the signer already exists in either the `AccountEntry`, or the additional signers entry, updates its weight instead.

Fails if a new signer is being added and an account already has `MAX_SIGNERS` (20) additional signers in the contract data entry.

##### `remove_ed25519_signer`

Removes an existing ed25519 signer from the account. The signer may be present in either the `AccountEntry`, or the additional signers entry (if any).

When a signer is removed from the `AccountEntry`, it might be sponsored. In that case the sponsorship information is updated accordingly in both the affected account and its sponsor, i.e. base reserve is returned to the sponsor. This update does not require additional authorization from the sponsor, so it can be performed by the Soroban Host by just changing 2 account entries accordingly.

Fails if the signer does not exist.

##### `update_delegated_signer`

Adds a new delegated signer with the provided `Address` and the provided weight to the additional signers entry as `ACCOUNT_SIGNER_DELEGATED` signer. If the signer already exists, updates the weight instead.

Fails if a new signer is being added and an account already has `MAX_SIGNERS` (20) additional signers in the contract data entry.

##### `remove_delegated_signer`

Removes an existing delegated signer from the account's additional signers entry.

Fails if the signer does not exist.

##### `set_master_weight`

Sets the weight of the 'master' key, i.e. the public key that identifies the account. The weight is updated in the `AccountEntry`.

##### `update_thresholds`

Updates the signature thresholds of the account when the corresponding arguments are set for the low/medium/high thresholds. The threshold are updated in the `AccountEntry`.

## Design Rationale

### Implicit account contracts

There is no need to explicitly created a contract instance for the G-accounts. This reduces the complexity compared to the Stellar Asset contract and reduces the necessary ledger state size. While this approach means that there is no way to opt out from the account being accessible via GAC, the account implementation has the same authorization requirements as the existing account management operation (`SetOptionsOp`), so there is no additional risk surface or cost induced by the implicit GAC instances.

### Additional signers entry and state archival

This CAP sets the precedent for using the contract data that is subject to state archival in the 'classic' flows, both during the transaction validation for every transaction on-chain, as well as in the classic operation (account merge). This is not the only possible approach: an alternative could be to add delegated signers directly to the `Signer` XDR and store them in the `AccountEntry`. However, that would come with an additional complexity when interacting with the classic semantics from Soroban, as normally Soroban does not interact with sponsorships and doesn't increase base reserves.

The design used in the proposal avoids the potential issues that using the archived state in the classic flows could introduce. Only live Soroban state lookups are necessary during the signature validation and transaction execution, which is cheap because the state is in memory.

### CAP-71 dependency

This CAP benefits from the authentication mechanism introduced in [CAP-71](./cap-0071.md). It allows using a single authorization entry for an account with delegated signers and simplifies the simulation and overall developer experience.

This CAP could technically be implemented without CAP-71 by using the existing delegation approach (described in CAP-71 [motivation](./cap-0071.md#motivation) section). However, that would come with a much worse developer experience, and is also hard to change going forward. That's why CAP-71 is a pre-requisite for this CAP.

## Security Concerns

A new way to modify G-account settings is introduced. As usual for the sensitive authorization-related code, the main risk lies in the implementation correctness, thus it has to be reviewed and tested thoroughly. However, the design itself does not introduce any new risks from the protocol standpoint: the new account interface has the same high signature threshold as the `SetOptions` operation and only allows performing modifications that are a subset of `SetOptions`.

Adding delegated, contract-based signers comes with a risk for a user: every contract signer added to the account has to be a trusted and audited contract. This risk exists for any contract-based account in general. The users don't have to add contract signers to the account - if they don't do that, they are not subject to any new risks.

## Test Cases

TBD

## Implementation

TBD