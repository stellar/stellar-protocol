```
CAP: 0053
Title: Smart Contract Host Functionality: JSON Decoding
Working Group:
    Owner: Leigh McCulloch <@leighmcculloch>
    Authors: Leigh McCulloch <@leighmcculloch>
    Consulted:
Status: Draft
Created: 2023-02-15
Discussion: TBD
Protocol version: TBD
```

## Simple Summary

Support JSON decoding, as specified in [RFC7159], in Soroban contracts via the
exported host interface.

## Motivation

JSON is a common encoding in other systems. Decoding JSON is something that can
be done in contract code under the limits known today, using the
`serde-json-core` crate, however when paired with an allocator contract size and
cost to run starts to grow.

When using a statically allocated buffer of sufficient size and decoding a small
message and extracting a single field, such as those found in webauthn:
- WASM Size = 3,901 bytes
- CPU Instructions = 2,407,958

When using dynamically allocated memory and decoding a small message and
extracting a single field, such as those found in webauthn:
- WASM Size = 8,270
- CPU Instructions = 4,278,990

Soroban's initial design was influenced by reducing encoding/decoding churn
within contracts. While JSON isn't the format of choice for communicating within
Soroban contracts, the reality is that some external systems produce JSON that
contracts need to be able to decode.

Additionally, even if efficient, this is a common standard that is simple to
decode host side and available in many standard libraries today.

### Goals Alignment

This CAP is aligned with the following Stellar Network Goals:

- The Stellar Network should make it easy for developers of Stellar projects to
  create highly usable products

## Abstract

This proposal adds a single function to the Soroban environment's exported
interface that takes `Bytes` as input, parses it as JSON, and returns a
`JsonValue`, a new `Val` type that may be passed to and from the guest and host,
but that has no `ScVal` representation as it can never be stored or exit the
host.

The proposal also adds other host functions for operating on a `JsonValue` to
get the type of value is contained within, convert the value into primitive
types like strings, bools, and numbers, and further navigate object and array
types.

## Specification

**TODO: Complete and flesh out this section.**

```diff mddiffcheck.ignore=true mddiffcheck.base=v20.1.0
+ json_parse(bytes) -> JsonValue
+ json_get_type(JsonValue) -> Symbol (null|bool|number|string|object|array)
+ json_get_bool(JsonValue) -> bool
+ json_get_number_as_i256(JsonValue) -> i256
+ json_get_number_as_u256(JsonValue) -> u256
+ json_get_number_as_i128(JsonValue) -> i128
+ json_get_number_as_u128(JsonValue) -> u128
+ json_get_number_as_i64(JsonValue) -> i64
+ json_get_number_as_u64(JsonValue) -> u64
+ json_get_number_as_i32(JsonValue) -> i32
+ json_get_number_as_u32(JsonValue) -> u32
+ json_get_string_as_symbol(JsonValue) -> Symbol
+ json_get_string_as_string(JsonValue) -> String
+ json_get_string_as_bytes(JsonValue) -> Bytes
+ json_get_array_len(JsonValue) -> u32
+ json_get_array_element(JsonValue, u32) -> JsonValue
+ json_get_array_as_bytes(JsonValue) -> Bytes
+ json_get_object_property(JsonValue, Symbol|String) -> JsonValue
```

### Design Rationale

#### Parse-then-Extract Model

This proposal proposes a parse then extra model, where parsing makes no
assumptions about how the data within the JSON message should be mapped to the
type system within Soroban contracts. After parsing contracts may choose how to
navigate the message, what fields to extract, and what type to interpret them as
when extracting. This opens up the most flexibility and the most resilience to JSON values that may not be supported by Soroban.

#### Numbers

Numbers in JSON are decimals, however Soroban supports only integers in varying bit-sizes.

**TODO: Discuss limitations.**

#### Strings

Strings in JSON are UTF-8, however Soroban Strings are arbitrary bytes.

**TODO: Discuss limitations.**

#### No Encoding

#### Webauthn / Passkeys

The JSON encode/decode interface is largely motivated by the webauthn use case.
Webauthn involves an application and device holding a key and using that key for
authentication and authorization.

The messages that Webauthn signs are JSON, but most of the fields are not
relevant to the contract. The challenge field is the only field that needs to be
extracted.

For example, a client data JSON:
```json
{
  "type":"webauthn.get",
  "challenge":"hJHFvaaoU7qkcH9kML46shLL_btpYGCA6ty3ie0M1Qw",
  "origin":"http://localhost:4507",
  "crossOrigin":false
}
```

## Protocol Upgrade Transition

### Backwards Incompatibilities

This proposal is completely backwards compatible.

### Resource Utilization

#### Metering

The new functions must be appropriately metered.

## Security

### Strict

Some applications that use base64 require that their base64 decoders are strict
in regards to the presence or non-presence of padding. Applications that fall
into this category may be applications that need to ensure that data encoded
always has a single representation in the encoded form. For this reason it is
relatively important that the variants supported include the ability to require
that decoding fail if indicated by the application that strict decoding is
required.

## Test Cases

None yet.

## Implementation

None yet.

[Webauthn]: https://www.w3.org/TR/webauthn-2/
[RFC7159]: https://datatracker.ietf.org/doc/html/rfc7159
