
## Preamble

```
SEP: Not assigned
Title: Txrep: human-readable low-level representation of Stellar transactions
Author: David MaziÃ¨res
Status: Draft
Created: 2018-08-31
```

## Simple Summary

Txrep is a human-readable representation of Stellar transactions, akin
to an "assembly language" for XDR.

## Abstract

This document specifies _txrep_, a human-readable format for Stellar
transactions.  Txrep is unambigous and machine-parsable.  Binary XDR
transactions can be disassembled into txrep format and recompiled to
the exact same binary bytes.  Txrep is designed to be parsed directly
into data structures generated by XDR compilers, ideally by the very
XDR code generated by those compilers.

## Motivation

Bug reports, test vectors, semantic specifications in CAP documents,
and Stellar documentation all need a way to talk concretely about the
contents of transactions.  Without a canonical textual format,
different documents will each devise their own way of describing
transactions, sometimes ambiguously, making it hard to relate
information from multiple sources.

Furthermore, advanced Stellar users and devlopers need a way to craft
arbitrary transactions, including potentially invalid ones for test
cases.  This functionality is currently available from the [Stellar
laboratory transaction
builder](https://www.stellar.org/laboratory/#txbuilder), but that is
not a good solution for high security, as it requires a browser (and
in practice requires trusting an HTTPS certificate).  Moreover, the
transactions one builds in a web browser cannot easily be audited
before signing, or described in documentation, or scripted, or placed
under version control.

Finally, "dumb" ink-on-paper contracts may need to specify Stellar
transactions unambiguously.  For example, a legal contract promising
to deliver tokens with a lock-up period in exchange for a wire
transfer may want to specify the exact lock-up mechanism used through
a human readable description of the Stellar transactions involved.
Using txrep, this description can be unambiguous.

## Specification

A txrep file consists of a number of lines, each describing the value
of a field.  We describe the line format using a simple BNF-like
notation in which brackets ([...]) indicate optional contents, pipe
(|) indicates alternatives, and an asterisk (*) indicates zero or more
repetitions of the previous symbol.  Literal text (e.g., `:`, `.`,
`[`, `]`, `.present?`, `.len`, or `_`) indicates the occurence of
those specific characters in the txrep source.

Each line of txrep has the following format:

> _line_ = _field_ `:` SP* _value_ [_comment_] LF
>        | `:` _comment_ LF
>        | LF
>
> _comment_ = zero or more characters other than LF
>
> SP = space (ASCII 32)
>
> LF = newline (ASCII 10)

Blank lines are allowed, and any line starting with a colon (`:`) is a
full-line comment.  The _field_ and _value_ formats are described
below.

### Fields

A field has the following syntax:

> _field_ = _tag_ _selector_* [_pseudoselector_]
>         | _nested_pointer_field_ _selector_* [_pseudoselector_]
>
> _selector_ = `.` _tag_ | `[` _integer_ `]`
>
> _tag_ = _letter_ _wordchar_*
>
> _pseudoselector_ = `.present?` | `.len`
>
> _integer_ = A decimal integer
>
> _letter_ = Any letter
>
> _wordchar_ = Any letter, any digit, or `_`
>
> _nested_pointer_field_ = `(*` _field_ `)`

Disregarding _pseudoselector_, each _field_ names a field in an [XDR
`TransactionEnvelope` data
structure](https://github.com/stellar/stellar-core/blob/master/src/xdr/Stellar-transaction.x#L351).
The name is generated by joining XDR field names with a period (`.`),
similar to the syntax used for accessing nested fields in C++ or go
representations of XDR data structures.  Array elements (for both
fixed- and variable-length arrays) are indexed using square brackets.
As in C, arrays are 0-based.  The _nested_pointer_field_ syntax is
reserved in case `TransactionEnvelope` ever contains pointers to
pointers, but is not presently used since no fields have such types
anywhere in the XDR source file.

As an example, the _field_ `tx.timeBounds.minTime` names the `minTime`
field in the `tx` field of the `TransactionEnvelope` structure, which
looks like this:

```c
struct TimeBounds {
    uint64 minTime;
    uint64 maxTime; // 0 here means no maxTime
};
struct Transaction {
    /* ... */
    TimeBounds* timeBounds;
    Operation operations<100>;
    /* ... */
};
struct TransactionEnvelope {
    Transaction tx;
    DecoratedSignature signatures<20>;
};
```

Pointers and variable-length arrays use pseudoselectors to describe
their state.

Pointers use the `.present?` pseudoselector with value `true` or
`false` to indicate that the field is present or NULL, respectively.
For example, a transaction with timebounds might be specified like
this (using comments to annotate the times):

~~~~
tx.timeBounds.present?: true
tx.timeBounds.minTime: 1535756672 (Fri Aug 31 16:04:32 PDT 2018)
tx.timeBounds.maxTime: 1567292672 (Sat Aug 31 16:04:32 PDT 2019)
~~~~

A transaction without timebounds would contain this line:

~~~~
tx.timeBounds.present?: false
~~~~

Variable-length arrays use the pseudo-selector `.len` with an integer
value to indicate the number of elements of the variable-length array.
Only indices from 0 to len-1 are meaningful.  For example, a
transaction with one operation might look like this:

~~~~
tx.operations.len: 1
tx.operations[0].sourceAccount.present?: false
tx.operations[0].body.type: PAYMENT
...
~~~~

### Values

Most XDR types are rendered intuitively in a C-like syntax.
Specifically:

 * All integers (signed and unsigned, 32- and 64-bit) are represented
   as C integers (decimal by default, but prefix `0x` can be used for
   hex and `0` for octal).

 * `bool` values are `true` or `false`

 * Enums are represented by the bare keyword of the value.  They
   cannot be specified numerically (but omitting a line for a field is
   the same as specifying 0).

 * `string` values are represented as double-quoted interpreted string
   literals, in which non-ASCII bytes can be represented with hex
   escapes (`"\xff"`), the `"` and `\` characters can be escaped with
   another `\` (e.g., `"\\"`), and `\n` designates a newline.

 * `opaque` values are represented as an unquoted hexadecimal string
   (using lower-case case `a`...`f`)

A few aggregate values are special-cased:

 * The `AssetCode` field in `Assets` is rendered as ASCII bytes (not
   surrounded by double-quotes).  Non-printable characters and
   non-ASCII bytes (including space, to avoid a space being
   interpreted as part of a comment) are hex escaped (`\xff`), while
   backslash is self-escaped (`\\`).

 * `PublicKey` and `SignerKey` are rendered as unquoted strings in
   strkey format, described below.

Any fields in the XDR `TransactionEnvelope` structure that are not
specified in a txrep description are to be interpreted as zero (for
numeric values, enums, and fixed-length `opaque`) and zero-length (for
strings, variable-length arrays, and variable-length `opaque`).

### Strkey format

Strkey provides a compact ASCII format for ED25519 public keys,
ED25519 private keys (also known as seeds), pre-authorized transaction
hashes, and hash-x signers (which provide signing authority upon
revelation of a SHA-256 preimage).  Each of these four types has a
corresponding version byte, which determines the first character of
the strkey encoding:

| Key type | Version byte | First char |
| --------------------- | -- | ---- |
| STRKEY_PUBKEY_ED25519 | 6  | G  |
| STRKEY_SEED_ED25519   | 18 | S  |
| STRKEY_PRE_AUTH_TX    | 19 | T  |
| STRKEY_HASH_X         | 23 | X  |

The following steps transform a binary key into a strkey:

1. Prepend the appropriate version byte to the binary key (so, e.g., a
   32-byte ED25519 public key becomes 33 bytes).

1. Compute a 16-bit CRC16 checksum of the combined version byte and
   binary key (using polynomial x<sup>16</sup> + x<sup>12</sup> +
   x<sup>5</sup> + 1).  Append the two-byte checksum to the version
   byte and binary key (e.g., producing a 35-byte quantity for an
   ED25519 public key).

1. Encode the concatenated Version-byte, Binary-key, and CRC16 using
   [RFC4648 base-32 encoding](https://tools.ietf.org/html/rfc4648#section-6).

The strkey format is already widely used for Stellar.  Among others,
implementations exist in
[go](https://github.com/stellar/go/blob/master/strkey/main.go),
[C++](https://github.com/stellar/stellar-core/blob/dd7f38dba232e20ae75a95641857c0b7ed0252e1/src/crypto/StrKey.cpp),
and
[JavaScript](https://github.com/stellar/js-stellar-base/blob/master/src/strkey.js).

### Normalized txrep

Fields in txrep are specified in an order-independent way.  If a field
appears twice, the second value overwrites the first.  This allows one
to update a transaction by appending lines to a file.  However, in
some cases it is useful to transform transactions into normalized
form, for instance so two transactions can be more easily compared, or
so users inspecting a transaction see a more predictable format.

_Normalized txrep_ format is a _txrep_ format with the following
additional restrictions:

* Every field and pseudofield in the the binary XDR transaction must
  appear exactly once in the description.  Extraneous fields or fields
  that do not appear because of NULL pointers or incompatible union
  discriminants must not appear.

* Fields in structs and unions must appear in the exact order they
  appear in the XDR file, which is also the order in which they are
  marshaled for XDR binary format.

* Pseudo-fields must appear immediately before the values they affect.
  In particular, the `ptr.present?: true` field must appear immediately
  before the value of `ptr`, and `vector.len` must appear immediately
  before `vector[0]`.

## Rationale

This format is human-readable and extensible to future transaction
updates as the XDR files change.  Having each line be self-contained
means that one can excerpt any subset of a transaction with no
ambiguity.  The format is also trivial to parse programatically.
Pretty much every language has functions to read files line-by-line
and break strings at a specific character (to separate field and value
at `:`).  Printing field and value is even more trivial.  This means
security-sensitive applications can avoid depending on external
libraries for more complicated formats such as JSON or XML.

Two special cases (for keys and assets) make the output easier for
humans to process by providing compatibility with other tools.

The `.present?` pseudoselector was selected to avoid conflicting with
fields in the same data structure, since no field can contain the
character `?`.  There is no similar ambiguity possible for `.len`,
whose only siblings are bracketed array indices.

## Test Cases

The following binary transaction:

~~~~
AAAAACsWS5BDhC5BjpKQtznHFJ3CkU6+XtWopW+t+Q9KoH7QAAAAZAClKY0AAAABAAAAAQAAAABbicmAAAAAAF1q/QAAAAABAAAAFkVuam95IHRoaXMgdHJhbnNhY3Rpb24AAAAAAAEAAAAAAAAAAQAAAABAXzbt2M8i77+AcrmFtqTAFVHDTdOME3rI1A1ALNH3tAAAAAFVU0QAAAAAADJSVDIhkp9uz61Ra68rs3ScZIIgjT8ajX8Kkdc1be0LAAAAABfXk6AAAAAAAAAAAUqgftAAAABA3vtPH60cJ5MntVrxhP3N33P096jLQOflNKcdc6BRJLo2nbem0xtHyv0RhZIkaoV15sJJq5TsN2je22KSIhzlDA==
~~~~

Can be rendered like this (note that comments are optional and may
contain implementation-dependent information):

~~~~
tx.sourceAccount: GAVRMS4QIOCC4QMOSKILOOOHCSO4FEKOXZPNLKFFN6W7SD2KUB7NBPLN
tx.fee: 100
tx.seqNum: 46489056724385793
tx.timeBounds.present?: true
tx.timeBounds.minTime: 1535756672 (Fri Aug 31 16:04:32 PDT 2018)
tx.timeBounds.maxTime: 1567292672 (Sat Aug 31 16:04:32 PDT 2019)
tx.memo.type: MEMO_TEXT
tx.memo.text: "Enjoy this transaction"
tx.operations.len: 1
tx.operations[0].sourceAccount.present?: false
tx.operations[0].body.type: PAYMENT
tx.operations[0].body.paymentOp.destination: GBAF6NXN3DHSF357QBZLTBNWUTABKUODJXJYYE32ZDKA2QBM2H33IK6O
tx.operations[0].body.paymentOp.asset.type: ASSET_TYPE_CREDIT_ALPHANUM4
tx.operations[0].body.paymentOp.asset.alphaNum4.assetCode: USD
tx.operations[0].body.paymentOp.asset.alphaNum4.issuer: GAZFEVBSEGJJ63WPVVIWXLZLWN2JYZECECGT6GUNP4FJDVZVNXWQWMYI
tx.operations[0].body.paymentOp.amount: 400004000 (40.0004e7)
tx.ext.v: 0
signatures.len: 1
signatures[0].hint: 4aa07ed0 (GAVRMS4QIOCC4QMOSKILOOOHCSO4FEKOXZPNLKFFN6W7SD2KUB7NBPLN)
signatures[0].signature: defb4f1fad1c279327b55af184fdcddf73f4f7a8cb40e7e534a71d73a05124ba369db7a6d31b47cafd118592246a8575e6c249ab94ec3768dedb6292221ce50c
~~~~

## Implementation

Txrep is implemented by the Stellar transaction compiler,
[stc](https://github.com/xdrpp/stc).
