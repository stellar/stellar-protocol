## Preamble

```
SEP: <to be assigned>
Title: Bootstrapping Multisig Coordination
Author: Paul Selden <paul.selden@stellarguard.me>, Nikhil Saraf <nikhil@interstellar.com>
Status: Draft
Created: 2018-10-30
```

## Simple Summary

Provides a standard way for multisig accounts to designate where transactions should be submitted for coordination of additional signatures.

## Abstract

An account may designate which multisig server to use in a data entry that points to a server with a `stellar.toml` file. This file contains a `MULTISIG_SERVER` field which is an API where multisig transactions should be submitted. Wallets should implement this SEP so they can support multisig accounts without requiring them to run a multisig service themselves.

## Motivation

Currently there are only a few public tools that allow for multisig accounts, and they all do it by implementing their own signature coordinator services to do so. Wallets or other services that do not implement their own backends have no real way to deal with multisig accounts, so most of them just don't at all. By allowing an account to specify where they want their multisig transactions submitted to, it enables those wallets to interop with existing multisig services without relying on vendor-specific SDKs and APIs.

Additionally, there may be use cases where users do not want their multisig transactions broadcasted to a public coordinator, but would still like to use existing wallets to submit them to a private coordinator.

## Specification

### Account Data

A multisig account adds a data entry with the key `multisig.domain` and the value of a hostname used to resolve the `stellar.toml` file of the multisig service.

Example:
Key: `multisig.domain`
Value: `stellarguard.me`

## Multisig Server stellar.toml

Multisig coordinators advertise the existence of their service through the `stellar.toml` file. The top-level parameter `MULTISIG_ENDPOINT` should contain a fully-qualified URL of a multisig coordination service where transactions will should be submitted.

Example of `stellar.toml`:
```
MULTISIG_ENDPOINT="https://stellarguard.me/api/transactions"
```

### Multisig Server API Endpoints

Multisig Services must expose two REST API endpoints.

#### Submit Transaction Endpoint

This is the endpoint defined in the `stellar.toml` under the `MULTISIG_ENDPOINT` key.

**Request**

An HTTP `POST` to `<MULTISIG_ENDPOINT>` using ContentType `application/x-www-form-urlencoded`.

Request Body Parameters:

- **uri** - A [SEP-0007 style](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0007.md)  `tx` URI for the transaction to sign.

Example:

```
POST https://stellarguard.me/api/transactions 

Body:
uri=web%2Bstellar%3Atx%3Fxdr%3DAAAAAHFd0%252BHQV5u%252FY%252FfM3%252BVelUr1IWwSFL8CUDIAUudUdD4MAAAAZAADyI8AAAADAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAcV3T4dBXm79j98zf5V6VSvUhbBIUvwJQMgBS51R0PgwAAAAAAAAAAACYloAAAAAAAAAAAVR0PgwAAABAEw8ODG0iixkbAHg1aJATAnZS2531PhGauuSvFDad2WxHKzIenUNbc7K5mGiSpe5jvqe19OQCbNFuBjqN11jfBw%253D%253D
```

**Response**

On success, the endpoint should return 200 OK HTTP status code and a JSON-encoded object.

Response fields:

- **_links.status** - Required. A fully qualified url where an agent can poll for updates on the status of the multisig request.
- **id** - Required. An identifier for the multisig request that is generated by the multisig service.
- **extras** - Optional. An object that contains additional application specific response data which could be used to provide an enhanced user experience. For instance, showing a link to authorize a transaction.

Example:

```json
{
  "_links": {
    "status": "https://stellarguard.me/api/transactions/c585ceee-b1b9-4009-aa37-b8544346a036/status"
  },
  "id": "c585ceee-b1b9-4009-aa37-b8544346a036",
  "extras": {
    "stellarGuard": true,
    "url": "https://stellarguard.me/transactions/c585ceee-b1b9-4009-aa37-b8544346a036"
  }
```

#### Status Endpoint

This will be used to query for the status of a multisig transaction.

**Request**

An HTTP `GET` to `<_links.status>`.

Request Parameters:

The url in `<_links.status>` should include all parameters needed to look up the transaction.

Example:

```
GET https://stellarguard.me/api/transactions/c585ceee-b1b9-4009-aa37-b8544346a036/status
```

**Response**

On success, the endpoint should return 200 OK HTTP status code and a JSON-encoded object.

Response fields:

- **id** - Required. An identifier for the multisig request that is generated by the multisig service.
- **status** - Required. An string indicating the status of the multisig request which can have one of the following values:
  - `pending` - The request requires more signatures
  - `success` - The transaction has been fully signed

Example:

```json
{
  "id": "c585ceee-b1b9-4009-aa37-b8544346a036",
  "status": "pending"
  }
```

####  CORS headers

In order to comply with browser cross-origin access policies, the service should provide wildcard CORS response HTTP header. The following HTTP header must be set for the API endpoints:

```
Access-Control-Allow-Origin: *
```

### Multisig Transaction Flow

1. Determine whether a transaction requires additional signatures in order to be valid.
1. If the transaction requires more signatures, look up the data entry with the key `multisig.domain` on the transaction source account.
1. Resolve the `stellar.toml` associated with the account's `multisig.domain` entry and return the `MULTISIG_ENDPOINT` field.
1. Convert the transaction to a SEP-0007 style URI, setting any additional parameters such as `callback`.
1. `POST` to the `MULTISIG_ENDPOINT` endpoint with the SEP-0007 `tx` URI in the body as the parameter `uri`. The xdr in the transaction must be signed by a a valid signer or else the server should respond with an error.
1. The service responds with 200 with a JSON object specified in the Submit Transaction Endpoint Response section.

## Rationale

When implementing StellarGuard for the Stellar Account Viewer, it was rightly pointed out that it was trying to avoid vendor-specific implementations such as the one that was provided (https://github.com/stellar/account-viewer/pull/68#issuecomment-410746896). Instead, we discussed an alternative approach that could be used by other products and tools that want to support multisig without implementing it over and over again for each service..

Another design choice was whether to skip the `stellar.toml` step and add the fully qualified multisig server endpoint to the account's data field. I believe that the `stellar.toml` approach affords greater flexibilty for the server to change its implementations, since it is much easier to update the `stellar.toml` than to update the data entry of every account that uses it.

### Previous Discussion

I initially introduced the idea on GalacticTalk: https://galactictalk.org/d/1651-a-vendor-agnostic-way-to-bootstrapping-multisig-coordination, and the idea was met with mixed reviews. The primary argument was that it doesn't go far enough and provide the full story about how to actually handle the multisig coordination. However, I feel that fully specifying that part of it would actually limit its usage, as there may be use-case specific implementation details.

## Implementations

The server implementation is currently live on [https://test.stellarguard.me](https://test.stellarguard.me) and [https://stellarguard.me](https://stellarguard.me).

A library that implements this protocol has been published here: [https://github.com/stellarguard/multisig-utils](https://github.com/stellarguard/multisig-utils)

A demo using that library that submits to the StellarGuard multisig endpoint: [https://stellarguard.github.io/multisig-utils/demo/](https://stellarguard.github.io/multisig-utils/demo/)

## Outstanding Questions/Discussion

1. Should we specify that multisig services expose and return a `_links.status` field for status updates in the response data and also dictate how that should endpoint should function? Applications may have specific use-cases or implementations that this may not work with (for instance, what if they want to use event source or websockets instead of a polling endpoint -- or if they do not want to expose a public status endpoint at all for privacy reasons). However, if we do not specify exactly how it should work then its possible there will be multiple incompatible implementations.

1. Should we use `MULTISIG_SERVER` or `MULTISIG_ENDPOINT` as the key in stellar.toml. `SERVER` is consistent with the naming of `FEDERATION_SERVER`, but `MULTISIG_ENDPOINT` more accurately describes that it is not just a hostname, it's the actual path to the endpoint.

1. Do we need to specify `application/x-www-form-urlencoded` as the content type for the POST data? Or leave it up to the client and expect the server to be able to negotiate multiple content types such as application/json?

1. Naming of the `uri` parameter in the POSTed data. Any better names?

1. What should the data entry key be for the multisig domain? `multisig.domain` aligns with any particular "namespaces" implementation that may come out of [this discussion](https://github.com/stellar/stellar-protocol/pull/199). However `multisig_domain` is more consistent with the field `home_domain` used on the account.